---
layout: post
title: In-depth look at Customizing Type Layout with ReSharper
categories: []
tags:
- ReSharper
status: publish
type: post
published: true
meta:
  reddit: a:2:{s:5:"count";i:0;s:4:"time";i:1385704322;}
  _elasticsearch_indexed_on: '2011-01-04 09:13:15'
comments: true
---
<p>When we run Code Cleanup with <a href="http://www.jetbrains.com/resharper">ReSharper</a>, one of the options it has is to re-order the member layout in classes. This means that some ugly layout like this</p> <p><a href="http://hhariri.files.wordpress.com/2011/01/image7.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb7.png" width="426" height="431"></a> </p> <p>can be turned into this</p> <p><a href="http://hhariri.files.wordpress.com/2011/01/image8.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb8.png" width="422" height="408"></a> </p> <p>(you need to have <strong>Reorder Type Members </strong>checked). </p> <p>The advantage is that we don’t need to constantly worry about making sure properties and fields are declared in their correct position, wasting time manually re-arranging code. </p> <p>What happens however when we don’t agree with <a href="http://www.jetbrains.com/resharper">ReSharper’s</a> choice in layouts? Recently I came across this situation when I ran the clean-up (by mistake) on my Specifications project. I use MSpec and I like to keep certain things in certain places. In particular, with MSpec you make use of statics and I like to have them placed at the bottom of each class where I can ignore them.</p> <p><a href="http://hhariri.files.wordpress.com/2011/01/image9.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb9.png" width="418" height="321"></a> </p> <p>Of course, when I ran ReSharper clean up, I ended up with</p> <p><a href="http://hhariri.files.wordpress.com/2011/01/image10.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb10.png" width="418" height="284"></a> </p> <p>So what to do? Well, I am aware of the possibility of modifying how type members are ordered in ReSharper, the problem with it however is that it’s global, that is, you can’t change it per project. What hadn’t occurred to me (talk about not looking at the default pattern. Thanks <a href="http://twitter.com/agross">Alex</a>) was to bind the customization to MSpec’s <strong>Subject </strong>attribute that specifications have (albeit it is not required but nice practice).&nbsp; Although much of the work is done, I thought it would be a good opportunity to delve a bit more into customizing layouts since it could probably benefit others. So here goes…</p> <h3>Customizing Type Layouts</h3> <p>Layout is defined in ReSharper using XML which is defined under <strong>ReSharper | Options | Languages | C# | Type Member Layout</strong></p> <p><a href="http://hhariri.files.wordpress.com/2011/01/snaghtml70374c6.png"><img style="display:inline;border-width:0;" title="SNAGHTML70374c6" border="0" alt="SNAGHTML70374c6" src="http://hhariri.files.wordpress.com/2011/01/snaghtml70374c6_thumb.png" width="359" height="376"></a></p> <p>To get access to the default pattern and customize it, we need to uncheck the <strong>Use Default Patterns </strong>checkbox, which then causes the editor to display the text. Don’t be scared! </p> <p><a href="http://hhariri.files.wordpress.com/2011/01/image11.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb11.png" width="365" height="384"></a>&nbsp; </p> <p>What we see is the XML file that defines the pattern layout. Most of the text is actually comments defining how things are layout. The actual patterns start lower down (although there’s no scrollbar, you can scroll). Here is the same contents in a nicely XML highlighted view</p> <p><a href="http://hhariri.files.wordpress.com/2011/01/image12.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb12.png" width="432" height="399"></a> </p> <p>A Pattern (<strong>&lt;Pattern&gt;&lt;/Pattern&gt;</strong>) consists of multiple entries (<strong>&lt;Entry&gt;&lt;/Entry&gt;</strong>). Each entry in turn represents some type of member. The order of these entries define the order in which the code is laid out. Let’s take a look at an entry in more detail</p> <p><a href="http://hhariri.files.wordpress.com/2011/01/image13.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb13.png" width="369" height="181"></a> </p> <p>Each entry consists of a <strong>&lt;Match&gt; </strong>element and optionally a <strong>&lt;Sort&gt; </strong>and <strong>&lt;Group&gt; </strong>element. <strong>&lt;Match&gt; </strong>in turn consist of one or more Operands combined using <strong>&lt;And&gt;</strong>/<strong>&lt;Or&gt;</strong> and negated with <strong>&lt;Not&gt;</strong>. An Operand can be:</p> <table border="1" cellspacing="0" cellpadding="0" width="903"> <tbody> <tr> <td valign="top" width="455"><strong>Operand</strong></td> <td valign="top" width="446"><strong>$val can be..</strong></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;Kind Is=”$val” [Order=”$val”]&gt;</font></td> <td valign="top" width="446"> <p><font size="2">class, struct, interface, enum, delegate, type, constructor, destructor, property, indexer, method, operator, field, constant, event or member</font></p></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;Name Is="$val” [IgnoreCase=”true/false”]&gt;</font></td> <td valign="top" width="446"><font size="2">Regular expression. IgnoreCase indicates whether to ignore case</font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;HasAttribute CLRName=”$val” [Inherit=”true/false”]&gt;</font></td> <td valign="top" width="446"><font size="2">Regular expression. Inherit indicates if it applies to inherited classes.</font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;Access Is=”$val”&gt;</font></td> <td valign="top" width="446"><font size="2">public, protected, internal, protected internal, private</font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;Static/&gt;</font></td> <td valign="top" width="446"><font size="2"></font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;Abstract/&gt;</font></td> <td valign="top" width="446"><font size="2"></font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;Virtual/&gt;</font></td> <td valign="top" width="446"><font size="2"></font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;Sealed/&gt;</font></td> <td valign="top" width="446"><font size="2"></font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;Readonly/&gt;</font></td> <td valign="top" width="446"><font size="2"></font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;ImplementsInterface CLRName=”$val” [Immediate=”true/false”]&gt;</font></td> <td valign="top" width="446"><font size="2">Regular expression</font></td></tr> <tr> <td valign="top" width="455"><font size="2">&lt;HandlesEvent/&gt;</font></td> <td valign="top" width="446">&nbsp;</td></tr></tbody></table> <p>Taking this into account, if we look at the previous pattern, we see that we are trying to match constructors, specifying (optional) that static constructors should be ordered first. Let’s take a look now at a more “complicated” pattern  <p><a href="http://hhariri.files.wordpress.com/2011/01/image14.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb14.png" width="281" height="265"></a>  <p>This pattern is for matching instance fields that are not static. What we do is identify fields using the <em>Kind </em>Operand and passing <em>field </em>as the value for the <em>Is </em>attribute. Since we are interested in non static fields, we add a <strong>&lt;Not&gt; </strong>operator around a <strong>&lt;Static/&gt; </strong>operand. We need to wrap this in an <strong>&lt;And&gt; </strong>operator (using Polish notation). Finally, let’s look at static fields and constant  <p><a href="http://hhariri.files.wordpress.com/2011/01/image15.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb15.png" width="347" height="234"></a>  <p>Here the pattern should match a constant or (<strong>&lt;Kind Is=”constant”&gt;</strong>) <strong>&lt;And&gt;</strong> a static field (<strong>&lt;Kind Is=”field”&gt;</strong>) which is <strong>&lt;Not&gt;</strong> static (<strong>&lt;Static/&gt;</strong>). Again, if we look at this using Polish (or prefix) notation, it is easy to understand.  <h3>Defining Multiple Patterns</h3> <p>Having understood the basics of how patterns are defined, we can now come back to solving our issue with MSpec. Our issue is where statics are located. One solution would be to move the static pattern to the lower part of the pattern. Problem of course is that this would effect all classes. We only want it to effect classes that are of MSpec, that is, have the <strong>Subject </strong>attribute. </p> <p>The key in solving this problem is to define a different pattern for MSpec classes. In the Pattern definition file, we can have multiple patterns. What we can therefore do, is add a new pattern specific for our MSpec classes. How will ReSharper choose which pattern to use? That’s solved easily by defining a <strong>&lt;Match&gt; </strong>as the first element of each Pattern</p> <p><a href="http://hhariri.files.wordpress.com/2011/01/image16.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb16.png" width="473" height="265"></a> </p> <p>We have defined a new pattern that has a <strong>&lt;Match&gt; </strong>element with an <strong>&lt;HasAttribute&gt; </strong>for the <strong>Subject </strong>attribute of MSpec. When we now run Code Cleanup, ReSharper will match the pattern with MSpec classes and apply the appropriate layout. In our case, the only thing we have defined is that static fields should be after all other entries (indicated by using the <strong>&lt;Entry/&gt; </strong>element). This means that we are leaving layout as is for everything else (in real-world scenarios, this might not be the case. The <a href="https://github.com/agross/machine.specifications/blob/master/Misc/mspec_member_layout.xml">MSpec file</a> defined by Alex in fact has a full nice layout for MSpec). </p> <h4>Giving Matches Weights</h4> <p>In the previous pattern definition, there would not be any conflicts between the default patter and that of MSpec because the <strong>&lt;HasAttribute&gt;</strong> element discriminates correctly only MSpec classes. What would happen however if two patterns would match? That is where the weight factor comes in. Each <strong>&lt;Match&gt;</strong> element can have a <strong>Weight </strong>attribute associated with it. In case of conflicts, the one with the highest weight wins.&nbsp;&nbsp; </p> <h3>Sorting, Grouping and Regions</h3> <p>In addition to matching elements and defining their positions, we can also specify sorting and grouping options with patterns. By providing a <strong>&lt;Sort&gt; </strong>element </p> <p>&nbsp;<a href="http://hhariri.files.wordpress.com/2011/01/image17.png"><img style="display:inline;border-width:0;" title="image" border="0" alt="image" src="http://hhariri.files.wordpress.com/2011/01/image_thumb17.png" width="385" height="265"></a> </p> <p></p> <p>and defining the Operand by which it is to be sorted, elements that match the pattern will follow the specified order. In a similar way, using the <strong>&lt;Group&gt; </strong>element, we can group similar constructs and optionally wrap them in regions. Many of these operands can take as attribute values the variable they represent. In the previous pattern, we are specifying as the region name the variable ${Name} which will be instantiated to the name of the type. </p> <p>One final option is the possibility (which many of us are thankful for) of removing regions on cleanup. Each <strong>&lt;Pattern&gt; </strong>element has an attribute <strong>RemoveAllRegions</strong> which can be set to true or false. By setting it to the latter, regions will be removed on code cleanup.</p> <p>As we can see, the possibilities of laying out type members when performing code cleanup are quite unlimited. The process is a little bit cumbersome, mostly due to the editor, although there are already planned improvements for ReSharper 6. Nonetheless, if you have any feedback, please send it now or log it in <a href="http://youtrack.jetbrains.net/issues/RSRP">YouTrack</a>.</p> <p><strong>[Download the </strong><a href="https://github.com/hhariri/Blog/tree/master/Various"><strong>XSD Schema here</strong></a><strong>]</strong></p>
