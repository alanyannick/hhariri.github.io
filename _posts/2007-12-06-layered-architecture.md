---
layout: post
title: Layered architecture
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _elasticsearch_indexed_on: '2007-12-06 08:10:24'
comments: true
---
<p>When developing applications using a layered architecture, one of the problems that arise is how to pass information through tiers, in particular between the data and business layer. Let's assume that we have an employee entity that accesses an employee data class to retrieve the information from the data store. Employee is in our business assembly and our repository and data layer is in our data assembly. The repository can and should ideally be in a separate assembly, however for simplicity we will keep it in the same for this example since it doesn't affect the situation. </p>  <p><img style="border-right:0;border-top:0;border-left:0;border-bottom:0;" height="146" alt=" URL.DOC" src="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_thumb.png" width="244" border="0" /></a></p>  <p>Since BusinessLayer calls EmployeeRepository to get an instance of a particular employee, BusinessLayer needs to reference DataLayer. In turn, since DataLayer creates an instance of type Employee, DataLayer needs to reference BusinessLayer. However, this causes a circular reference problem. </p>  <p>One solution to the problem would consist of using a DTO (Data Transfer Object) in a third assembly to transfer information. BusinessLayer will now reference DataTransfer, as will DataLayer, avoiding a circular reference. </p>  <p><a href="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_1.png"><img style="border-right:0;border-top:0;border-left:0;border-bottom:0;" height="105" alt=" URL.DOC" src="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_thumb_1.png" width="244" border="0" /></a></p>  <p>This however adds a new class to our domain which isn't strictly necessary. It also means that we now have to copy values from EmployeeDTO to an Employee class, since EmployeeRespository returns type EmployeeDTO. </p>  <p>Using interfaces and generics</p>  <p>In order to avoid the above situation, we can make use of interfaces and generics to solve the problem. Instead of having EmployeeDTO, we create an interface IEmployee that Employee implements. This interface only declares the properties employees will have. Methods are particular to the business needs and are only present in the actual Employee class. </p>  <p><a href="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_2.png"><img style="border-right:0;border-top:0;border-left:0;border-bottom:0;" height="169" alt=" URL.DOC" src="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_thumb_2.png" width="244" border="0" /></a></p>  <p>Let's look at the resulting code. </p>  <p><a href="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_3.png"><img style="border-right:0;border-top:0;border-left:0;border-bottom:0;" height="244" alt=" URL.DOC" src="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_thumb_3.png" width="151" border="0" /></a></p>  <p>The EmployeeRepository code should look something like the following</p>  <p><a href="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_4.png"><img style="border-right:0;border-top:0;border-left:0;border-bottom:0;" height="116" alt=" URL.DOC" src="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_thumb_4.png" width="244" border="0" /></a></p>  <p>However, we now face a new problem. FindEmployee is returning an EmployeeDL. To do so, it's calling EmployeeDL. EmployeeDL cannot reference BusinessLayer, since if it does, we'd be in the same boat (circular reference). EmployeeDL should return an IEmployeeDL. This seems simple enough, except it's not possible to create instances of interfaces for obvious reasons. This leaves us with the problem of returning an instance of EmployeeDL, and to do this we make use of generics. For this, we implement EmployeeDL in the following way</p>  <p><a href="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_5.png"><img style="border-right:0;border-top:0;border-left:0;border-bottom:0;" height="110" alt=" URL.DOC" src="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_thumb_5.png" width="244" border="0" /></a></p>  <p>We are forcing the generic type to implement IEmployee and also have a parameterless constructor. This allows us to create new instances of the type and also assign the properties of an employee object. The only thing left to do is change the EmployeeRepository to use this code.</p>  <p><a href="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_6.png"><img style="border-right:0;border-top:0;border-left:0;border-bottom:0;" height="85" alt=" URL.DOC" src="http://www.hadihariri.com/blogengine/image.axd?picture=WindowsLiveWriter/Layeredarchitecture_8127/%7B%25URL.DOC_thumb_6.png" width="244" border="0" /></a></p>  <p>We now have a clear separation of layers without the need of introducing additional classes to our domain, complicating the scenario when it's not completely required. </p>  <p>Note: The point of this post is to show you how to pass data between tiers without using auxiliary objects, whether this may be a DTO class, an XML file, a DataTable or DataSet or whatever else you might like. I'm not debating which method is better, although I have a preference for the one shown in this post. </p>
